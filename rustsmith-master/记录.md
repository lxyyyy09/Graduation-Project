### 运行和效果

运行脚本op.sh，或者gradle build

当前随机生成的rust程序可以通过编译，可以运行

### cliArgs越界处理
限制cliargs的index避免越界（加了个宏reconditioned_cliargs_index_access，越界时默认为0），parse的result为err时随机生成对应type的数据填充。

这里的index处理逻辑和vector、struct、tuple避免越界的逻辑不同，后者先生成声明语句，确保index或者elementName一定不会越界或者一定存在。而cliArgs的长度无法通过生成声明语句控制，完全取决于命令行参数，所以需要后期判断index是否越界。

### Rc相关函数添加
仿照Box实现Type、expression
1. 添加use std::rc::Rc：已实现
2. 在type中添加RcType：已实现
3. newRcExpression：已实现
4. 增加Rc类的函数，如strongcount等等：还没有添加

### String相关函数添加
仿照vector实现expression
1. strPushStr：已实现
2. len：已实现

### HashMap相关函数添加：
HashMapType:记录KVType；NewHashMapExpression:仿照StructInstantiationExpression
1. new()：NewHashMapExpression，已实现
2. insert()：HashMapInsertExpression，未实现，返回值为option，内部数据类型无法判断是否相同。

    例如选择相同类型时，需要option(int)，选择得到的是option(float)
3. remove()：HashMapRemoveExpression。insert还未实现，无法测试remove功能。返回值处理。
4. len()：HashMapLengthExpression，已实现
5. get().copied().unwrap_or()：HashMapElementAccessExpression，未实现
6. 在Type中添加HashMapType：已实现
```agsl
//
//@SwarmNode
//data class HashMapElementAccessExpression(
//    val expression: Expression,
//    val elementName: String,
//    override val symbolTable: SymbolTable
//) : RecursiveExpression, PartialMoveExpression, LHSAssignmentNode, ElementAccessExpression {
//
//    override fun rootNode(): Variable? {
//        return if (expression is LHSAssignmentNode) {
//            expression.rootNode()
//        } else {
//            null
//        }
//    }
//
//    override fun toRust(): String {
//        val keyType=getKeyType(expression)
//        val tmp=when(keyType.toRust()){
//            "i8","i16","i32","i64","i128"->0;
//            "u8","u16","u32","u64","u128","usize"->0;
//            "bool"->0;
//            else ->"InitialStringForHashMap";
//        }
//        return "${expression.toRust()}.get($elementName).cloned().unwrap_or($tmp)"
//    }
//
//    fun getKeyType(expr:Expression):Type{
//        return (expr.toType() as HashMapType).keyType
//    }
//    fun getValueType(expr:Expression):Type{
//        return (expr.toType() as HashMapType).valueType
//    }
//
//}

```
### 泛型
1. 考虑为struct添加泛型

### traits
1. 思路
   暂定：
   - 生成struct
   - 生成1~3个trait，每个trait内1~2两个方法
   - 每个trait，随机选择两个struct实现
   - 增加traits=mutablesetof<traitType>，记录生成的trait
   - 增加traitMap记录trait和struct映射关系，List<Pair<trait,struct>>
   ```
      pub trait Trait0 {
          fn TraitFun名() -> 返回类型; // 暂时固定参数为空
      }
      impl Trait0 for struct名 {
          fn TraitFun名() -> 返回类型 {
               // code可通过固定返回类型和参数，随机生成函数得到
          }
      }
      struct名.fun名   // traitExpression
   ```

2. 具体实现
- 仿照structType实现traitType。随机trait生成数traitNums，随机fun生成数funNums。
trait结构：trait名、setof<functions>
- 对每个trait，随机选择两个struct实现方法，将映射关系保存在traitStructMap中
- 对每个方法，通过随机生成函数实现   仿照generateMethods generatemethodcall methodcallexpression?
方法控制不加入符号表，避免错误调用？或者函数名不为fun+数字，改为trait名+Fun+数字
此处提取信息填充trait声明，保存在符号表中的traits中。
- 暂不实现方法调用
[//]: # (- 对每个方法调用，实际上是traitExpression。生成时根据返回值在traits中查找是否有满足要求的方法)

3. 进度
- 已添加traitType
- 未添加NewTraitExpression
- 未添加trait的function和struct生成逻辑

4. 问题
- 变量类型如何过滤掉trait?
- trait的struct和func如何生成？






