### 运行和效果
运行脚本op.sh
当前随机生成的rust程序可以通过编译，可以运行

### cliArgs越界处理
限制cliargs的index避免越界（加了个宏reconditioned_cliargs_index_access，越界时默认为0），parse的result为err时随机生成对应type的数据填充。

这里的index处理逻辑和vector、struct、tuple避免越界的逻辑不同，后者先生成声明语句，确保index或者elementName一定不会越界或者一定存在。而cliArgs的长度无法通过生成声明语句控制，完全取决于命令行参数，所以需要后期判断index是否越界。

### Rc相关函数添加
仿照Box实现Type、expression
1. 添加use std::rc::Rc：已实现
2. 在type中添加RcType：已实现
3. new：已实现
4. 可以考虑增加Rc类的函数，如strongcount等等

### String相关函数添加
仿照vector实现expression
1. strPushStr：已实现
2. len：已实现

### HashMap相关函数添加：
HashMapType:记录KVType；NewHashMapExpression:仿照StructInstantiationExpression
1. new()：NewHashMapExpression，已实现
2. insert()：HashMapInsertExpression。返回值怎么处理？
3. remove()：HashMapRemoveExpression。insert还未实现，无法测试remove功能。且同时返回值怎么处理？
4. len()：HashMapLengthExpression，已实现
5. get().copied().unwrap_or()：HashMapElementAccessExpression
6. 在Type中添加HashMapType：已实现
```agsl
//
//@SwarmNode
//data class HashMapElementAccessExpression(
//    val expression: Expression,
//    val elementName: String,
//    override val symbolTable: SymbolTable
//) : RecursiveExpression, PartialMoveExpression, LHSAssignmentNode, ElementAccessExpression {
//
//    override fun rootNode(): Variable? {
//        return if (expression is LHSAssignmentNode) {
//            expression.rootNode()
//        } else {
//            null
//        }
//    }
//
//    override fun toRust(): String {
//        val keyType=getKeyType(expression)
//        val tmp=when(keyType.toRust()){
//            "i8","i16","i32","i64","i128"->0;
//            "u8","u16","u32","u64","u128","usize"->0;
//            "bool"->0;
//            else ->"InitialStringForHashMap";
//        }
//        return "${expression.toRust()}.get($elementName).cloned().unwrap_or($tmp)"
//    }
//
//    fun getKeyType(expr:Expression):Type{
//        return (expr.toType() as HashMapType).keyType
//    }
//    fun getValueType(expr:Expression):Type{
//        return (expr.toType() as HashMapType).valueType
//    }
//
//}

```
### 






